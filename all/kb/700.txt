INDEX
IntroductionInstall PapyrusVery simple data extracting - all lines in var arrayOutlineTextMarginOverflowFormat groupSimplex/DuplexBackerFooterPrint FooterPage number/count printingOutline Section, After Break , Before Break , BodyIntentional Page breakTable PrintCheck listCheck ImageJob Type s,f,eMessage managerOSI DNA Symmiter Message Manager with selective CriteriaDaily Letter/Notice -Writerecord for Daily(some s fields, no f)Print StepScriptInfoTracArchivalRedmine UpdateExcel Sheet fill upKeep reference
Introduction:
We mainly use Papyrus Designer tool to write our code. This basically generates dfa file with the extension *.dfa. In the designer program we use drag and drop building block to write our code, which in the back-end generates dfa scripts. When this dfa script is executed along with the input data file, an AFP file or PDF files is generated.
What is AFP file?
AFP Is A Collection Of Programs Used To Format And Print Documents. Using These Programs, You Can Define The Exact Placement Of Elements On A Printed Page, Assign Characteristics To The Various Elements, And Instruct The Printer To Print One Or More Copies Of The Document. Data Can Be Placed At Any Addressable Point On The Page, A Capability Known As All-points Addressability (APA).
Installing Papyrus:
The software comes in 2 cds. Please burn the 2 ISO files to 2 cds: ISIS_Disc1.iso, ISIS_Disc2.isoLoad disk1 onto CD-ROM driveFrom Auto Play, select Run SET_W32.exeTake English as the language, click >> to continueUncheck Hardlock key driverTake default for Source PathTake default for ISIS_cd.id fileTake default for Target PathTake default for ISIS_COMMON pathLeave Product code empty and hit >> to continueUnder Product Selection, keep the <Ctrl> key depressed to make the multiple selection:
Highlight ISIS DESIGN PRODUCTS header, all the modules under it will be selected
For ISIS PAPYRUS CLIENT PRODUCTS, pick the 1st 3 entries in that section
For ISIS DOCUMENTATION, highlight the section header to select all
For ISIS DOCUMENT SAMPLES, highlight the section header to select all
For the ISIS Tools, highlight the section header to select all
The next screen will show all the items selectedHit Start to start the installationLet the software create c:\ISIS folderInsert cd2 when prompted
Prepare the modules for usages
Copy the fonts300 folder in the zip file to overwrite the same folder in c:\isis. Overwrite the files already existing in c:\ISIS when prompted.From the zip file copy pddw3.prf, pdde.prf and DEFAULT.LBP to c:\isis\userisis to overwrite the same files thereSet up the following environment variables: ISIS_COMMON = C:\ISISCOMMISIS_KEY_MODE = ALLISIS_OMS_DOMAIN = 'ca-ipas-pr-02.infoimageinc.com' or '10.4.20.47'ISIS_OMS_PORT = 9091 
Fonts
Download this file 'http://cloud.dsinnovators.com/f/561451' and extract them into 'C:\isis\' directory 
Very Simple Data Extraction
Importing the Template project:
Download (click here) the Template project which will be named as template_stmt.zipOpen Papyrus DesignerClick: File > Import Project.Click on Browse button following the From filed and select the downloaded zip file.From the following window remove selection from the ...\default.prf and ...\Ppde.prfNext Copy the file available in a directory named imported inside the zip file and past in the c:/portal_file directory.If any error occurs it will be displayed in the Message List window. To see error messages click: Window > Message List
Observing The Code:
At this point 3 windows will be visible inside main window.
View Documents: Displays the generated outputDocument Format Definition: This where we write our primary codes. This section of code is called for each line.FormatGroup Definition: This section of script is called for printing each page
There are also some commands available for use.
To use any command drag and drop in the formatgroup definitions or document format definitions.
Overview of Execution:
In papyrus the execution of codes begin from the first "Docformat". A Docformat format is like a function of traditional programming language.
In our projects, execution begins for the main DocFormat which is always written before other docformats. The docformats are written in Document Format Definitions section.
In the picture there are 2 docformats named MAIN and PRINT_DOC. To call other docformat from a docformat.
In the above picture we called PRINT_DOC docformat from MAIN.
Reading Data from input file:
The record command () is used to read data from the input file. The variable command () is used to sore the last line read from the input data file.
Options for Variable command is shown in below figure. To get the options for any command please click right button of mouse above it.
The start parameter defines the starting column of the line that will be recorded and the length defines the length of the line to be recorded. Start is 1 and length is * means the line will be recorded from the column 1 to end of the line. If we observe first few lines of the code we will can see recorded line is being saved in a variable next CHANGE() function is used to remove unwanted characters. The assign command () is used to declare and assign values to variable. In this introductory project we have recorded one line from the input file and printed in the output file.
The input text file can be specified in "Line Data File Name" in Edit Document Project section of File tab.
Input Data File:
If we click on File>Edit Project we will see edit project window. On that window Line Data File Name field defines the path to input file.
Variable
A variable is used to store values during program execution (Note that a variable declaration is different from Variable command discussed in previous section of this tutorial.). A variable can be declared with Assign command.
In the above gif we declared a variable named 'TEMP_VARIABLE' and assigned a string "abcd". To view the value any variable go to windows tab and click variable and search for variable name.
Note: To apply changes in code press CTRL+R or click reload button like above GIF.
Outline:
All the commands that prints something in View Document section such as text, logo, barchart, rule, etc must be under another command called Outline. 
Here we printed a dummy text under outline command. The position sub-level commands in outline depend on the outline position. If outline position is 1 inch horizontal and 2 inch vertical then all the sub-level commands position will be calculated from 1 inch horizontal and 2 inch vertical. For example: If outline position is (horizontal, vertical)=(2 inch, 2 inch) and a sub-level command such as text position is (horizontal, vertical)=(4 inch, 7 inch) then the text will print on from (horizontal, vertical) = (2+4,7+2) = (6,9) position globally. we can also use other measurement such as MM, PELS, etc.
Text:
Text command is used to outputting text on the output file from the Outline. Like outline, position of a text can be specified. However, position of the Text command is computed relative to the immediate parent Outline command. To find Text command look for the text icon in the upper section of papyrus window and drag it in your it in your required section of the code.
Margin:
Margin command defines the margin around the logical page. If more than one margin is called the last called margin is the active margin measurement.
You can set margin by dragging the margin icon shown in the picture. To set margin right click on the icon after dragging and then set the margins. Here margins are set to 0 from all sides.
Overflow:
Overflow occurs when there are more contents in the current outline to print but the page is at its end. After an overflow, next logical is called. Also, calculation for the current is done after a page break. Print bunch of texts form an outline, debut and observe the overflow. In some cases when overflow we want to print something before break or after break. This can be done using section feature of outline. What the outline where an overflow may occur with two other outlines. Select the same section level for both outline at the end of the outline configuration window. In the Before_BREAK and AFTER_BREAK section elements can be added to execute before break or after break respectively.
Format Group
So far we have been working on Document Formant Definition window. We will use the Format Group Definition window to format grouped logical pages. Format Group definition holds the logic for logical pages. For instance, there are some formating applied to each logical pages, we define those in the Format Group Definition. Furthermore, logical page formatting are called after finishing each page. By default, next logical page is called after completing one logical page. A single format group can define one or more logical page definition.
Simplex/Duplex:
Format has definition for logical pages. When we need to print on both side a physical page or sheet we create two logical page definition in the Format group. We call this configuration Duplex configuration. In other situations we need to print on only one side a sheet. On those situations we create only one logical page definition inside the format group. We call this configuration Simplex configuration. However, it is not necessary to name format group simplex or duplex. We can assign it any name. Simplex and Duplex is the conventional names.
Backer:
Sometimes we are required to leave the back side of first page blank or print something special on it. This is called backer. We usually do this by maintain a variable to count page numbers and a conditional logic to check if it is the back of first page or not. After finding the back, we print the information if we have to, we manually call the next logical page, which starts the printing from the next page.
Footer:
In the logical pages of Format Group Definition, there is a section named Footer. This section is called immediately after a page ends. This section is used to count logical and physical pages and other issues that needs to be handled just after printing a page.
Print Footer:
Print footer section also lives inside logical page section. Print footer is called after printing all pages starting from the first page. This is helpful in situations where information need to print is available after printing all pages.
Page Number / Count Printing:
In our most projects we need to print page numbers. This can be done using the Footer section of logical page. However, sometimes we need to print the total number of pages beside the current page number. This information is not available before printing all pages. In this scenario we use the Print footer to print the page number. One variable is used to count the total number of pages and another variable is used in the print footer to hold the current page number.
Outline Section, After Break, Before Break, Body:
As mentioned in the Overflow section sections can be created with outlines. The idea has already been introduced in the Overflow section. To create a section we need to place two outlines having same section level.  Pare of the creates a section. Inside a section we can place body, before break and after break. Body holds the general elements. Before and after break is called when an overflow occurs due to other outlines inside a section. We should notice the fact, inside body any overflow will not call before break or after break.
Intentional Page Breaks:
Sometimes we need to intentionally break current page. For example, we have a table that we want to print but while printing it we see table heading may be along with fires 1 or 2 entries are only printed on the first page. However, we dont what this, rather when we dont have enough space we want to start printing from the next page. In other scenario we might pant to print some special content from the next pages and many other situations. In these situations we calculate the amount of space we have in our current page using few environment variables. They are as follows: $SL_MAXY  Maximum height of all elements inside the current element.
$ML_YPOS  Height of the current element in the current page.
$LP_HEIGHT  Height of the current logical page.
$MR_BOTTOM  Size of the bottom margin. Using these variables we can calculate the total height of the elements so far printed. If we observe current remaining space is less than our desired space we print an element may be a text at the margin having upward direction. This will cause the next elements to be printed from the next page.
Some Print Component
Table Print:
If we see our template project well find a line is being read from the input data file and the entire line is being printed as it is in the data file. However, this is not the case in our projects. Rather, we separate the information from a client and print as need. For example in the template project, the table we have at the middle is simple text print. Instate of that we need to print each cell, table heading, may be table grids, and style from the table separately. Now as update the template project so that each cell is printed separately. Make sure to purse the data separately as well.
Check List:
In the Table Printing task we have printed each row from the top to bottom. In some situations, mostly for displaying Check information we print list in several columns. Download the sample check list project from here and observe it. Youll see first a column is filled with rows from top to bottom and then moved to next column. Also, youll see is an overflow occurs all the columns in the existing page is filled firs and then printing is started from the next page. Try to write your own script to print in multiple columns.
Check Image:
Just like check list, for check image we intent to print images in several columns, mostly in two columns. We usually print images of check as check list. Click here to download the dummy check image project and observe. You will notice in the configuration of segment as shown in the figure, instate of using pseg for images we are using tiff file. Here filename specifies the name of the tiff file. DLL field must be specified to use tiff file as segment.
Job Type (s,f,e)
In print process, we produce file of several purposes. For instance, printing (which is our primary task), data file for e-statement, data file for archiving etc. We call this tasks as job types and while running DFA on the server we set an environment JOB_SEL. This variable is then checked the DFA and based on its value different output is produces. Job type s is used for printing statements, f is used for e-statement and e is used for archiving. Please observe the sample DFA for different job types. Click on file > Edit Project. On the Environment filed youll see several configurations are available. Among them, JOB_SEL configuration specifies the job type. One other important configuration is ZIPFILE. It holds the location of a text file. This file holds the output for different job type. When we are executing our program for job type s it creates a single afp which holds statements for all recipient. To separate each statement we need to know from which page a recipient starts. Along with this information other information are stored in this file. For job type f we generate separate afp for each user. In this case ZIPFILE will hold the names of the afp along with user information. For job type s, each field in the zipfile has fixed value and for job type f each value is separate by pipeline character(|). Job type e is used for the purpose of archiving by the bank. For job type e we use GROUP INDEX command to embed information at the starting of each user in the pdf. Observe the codes for each job type. Notes: LOCAL_ESTATEMENT_SET_VARIABLE is used to set variables for job type f.
Message manager
OSI DnaSometimes, our clients want to print different promotional messages for different clients. If you observe the portal file youll see several conditions. These conditions are executed in the DFA and different messages are printed according to the conditions. Following external DFAs are used to handle message managers: MSG_MGR_READ_CU_SEL_LIST and MSG_MGR_FORMAT_CU_MSG. Observe these DocFormats to understand how message managers are handles. Sometimes, a single statement can have more than one message to print. Below variables declared in the $_BEFOREFIRSTDOC to configure the message manager.
Tagged:basicfresherpapyrustraningtutorial